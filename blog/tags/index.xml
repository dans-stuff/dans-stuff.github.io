<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on WebVoxel Game Engine</title>
    <link>https://dans-stuff.github.io/blog/tags/</link>
    <description>Recent content in Tags on WebVoxel Game Engine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Apr 2021 21:40:12 -0700</lastBuildDate>
    
        <atom:link href="https://dans-stuff.github.io/blog/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>01 - Data Structures</title>
      <link>https://dans-stuff.github.io/blog/posts/01_data_structures/</link>
      <pubDate>Sun, 18 Apr 2021 21:40:12 -0700</pubDate>
      
      <guid>https://dans-stuff.github.io/blog/posts/01_data_structures/</guid>
      <description>&lt;h1 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h1&gt;
&lt;p&gt;Voxel engines come in many flavors. I want to compare and consider a few data structures for voxel data to find which is the most appropriate for this project.&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;List&lt;/h2&gt;
&lt;p&gt;The simplest data structure would be simply a list of voxels, specifying coordinate and type. Objects in game engines are almost always tracked in lists, as are particles.&lt;/p&gt;
&lt;p&gt;Pros&lt;br&gt;
+ The simplest in concept, adding a voxel to the world means adding it to a list&lt;br&gt;
+ Fast iteration, creation and deletion of voxels&lt;br&gt;
+ Memory usage scales with the amount of voxels&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Extremely slow random access by coordinate&lt;br&gt;
- Space inefficient for dense voxel scenes&lt;/p&gt;
&lt;p&gt;Lists could have special behaviour, such as always being sorted to allow for binary-search lookups, but finding a voxel by coordinate will always amount to a search through the list.&lt;/p&gt;
&lt;h2 id=&#34;octree&#34;&gt;Octree&lt;/h2&gt;
&lt;p&gt;This is the go-to data structure for sparse data, ie, data that tends to clump together. The short explanation is that octrees are a tree, where each branch encompasses a different region of space. If all of the data contained in a branch is the same, the branch is a &amp;ldquo;leaf&amp;rdquo; and has no children. If the data is varied, though, the branch if split into 8 smaller branches, each of which acts the same.&lt;/p&gt;
&lt;p&gt;In terms of voxels, this means large areas with identical voxels would be stored as a single leaf node, and only more detailed/varied areas would have deeper branches. The deeper the branches can go, the more detail you can represent.&lt;/p&gt;
&lt;p&gt;Pros:&lt;br&gt;
+ Extremely space efficient, capable of storing billions of voxels&lt;br&gt;
+ Changes to the tree provide deltas, efficient for networking&lt;br&gt;
+ Fast to raytrace, as large areas are skipped at each step&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Random access for a given coordinate is slow, especially when writing&lt;br&gt;
- Relatively complex to work with&lt;br&gt;
- Fixed size, tho new octrees could be created as needed for an infinite space&lt;/p&gt;
&lt;h2 id=&#34;pages&#34;&gt;Pages&lt;/h2&gt;
&lt;p&gt;Pages are often called chunks in the context of voxels. With pages, space is divided into an even grid, which is paged in and out of memory as needed. All of the pages would represent the same amount of space, and is at minimum a large flat buffer where each element in the buffer is one voxel.&lt;/p&gt;
&lt;p&gt;For any given coordinate you can determine the page and index within that page with constant time math. Reading or writing to that index is also constant time, and extremely fast.&lt;/p&gt;
&lt;p&gt;Pros:&lt;br&gt;
+ Conceptually very simple&lt;br&gt;
+ Fast, constant-time read and write operations&lt;br&gt;
+ Naturally infinite in all dimensions&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Space inefficient, constant size regardless of data&lt;br&gt;
- Fixed sense of scale&lt;/p&gt;
&lt;h2 id=&#34;in-the-context-of-webvoxel&#34;&gt;In the context of WebVoxel&lt;/h2&gt;
&lt;p&gt;Going back to WebVoxel&amp;rsquo;s intention, the engine should be flexible &lt;em&gt;enough&lt;/em&gt; to have many video game genres and mechanics layered on top, but must balance that against complexity. Here are some common ways in which the data structure will be important to a game developer building upom the engine:&lt;/p&gt;
&lt;p&gt;- Navigation. Players and NPC&amp;rsquo;s alike will be navigating the world in a manner specific and custom to the game.&lt;br&gt;
- Interaction. For some games, the voxel terrain may be nothing more than a solid static world, but for others interaction may be extremely high.&lt;br&gt;
- Rendering Performance. Every single game is going to be rendering the voxel scenes, but how dynamic the scene needs to be can have a big impact on how it is rendered.&lt;/p&gt;
&lt;p&gt;Any complexity in the data structure could be abstracted, but any game will have custom demands that are not suitable for a base engine and it&amp;rsquo;s extremely important that any custom mechanics are not made more difficult by the complexity of the engine.&lt;/p&gt;
&lt;p&gt;Lists are immediately rejected as a candidate, because navigation would be impractical thanks to the slow random access by coordinate. That said, rendering and interacting with a list is not particularly bad, as iteration is fast and conceptually easy. The game developer could simply iterate through all voxels to see if any of them need to be interacted with in any way.&lt;/p&gt;
&lt;p&gt;Octrees are a tough contender, as they can be abstracted to provide random access queries, but at a performance cost. Collision detection gets a bonus here, as bounding-box queries into an octree can be the fastest of the options. However, the complexity of octrees will undoubtedly leak to the game developer. Furthermore, two of the pros are irrelevant, as a browser game should not require hardware sufficient for raytracing, nor for interaction with billions of voxels. However, the networking capability is a very strong point in favor of octrees.&lt;/p&gt;
&lt;p&gt;Paging is the strongest contender, mainly due to it&amp;rsquo;s balanced approach. The complexity is small, as the most naive and obvious way to work with the structure will usually be the correct one. The space requirements would often be problematic, but in the context of web-based games, the amount of voxels will be small. Constant-time operations will help deliver smooth, uninterrupted gameplay. Also, the main issue unique to pages is the scale of the voxels, which in the context of web-games can be considered a positive. Interactions and game rules will only need to consider voxels with a fixed size, and level or scene development will be kept consistent and predictable.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, pages make the most sense. Web-based games are much smaller in scope and complexity, because they target consumers with low-powered hardware, such as phones and laptops. Additionally, they generally require lower commitment, and so the gameplay should be simple to learn quickly. This means that the benefits of a more complex data structure will never be realized, and the performance of a simpler data structure will be unsufficient.&lt;/p&gt;
&lt;p&gt;Going forward, the central data structure of WebVoxel will be buffers indexed by coordinate and paged in or out as needed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://dans-stuff.github.io/blog/about/</link>
      <pubDate>Sun, 18 Apr 2021 20:51:23 -0700</pubDate>
      
      <guid>https://dans-stuff.github.io/blog/about/</guid>
      <description>&lt;h2 id=&#34;the-dude&#34;&gt;The Dude&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;m Dan and I love difficult projects. My language of choice is Go, though I use native JavaScript when writing for the browser. If you want to contact me, my discord is SR|Dan#6804 and you can find me in the &lt;a href=&#34;https://discordapp.com/invite/anZVvmd&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Discord&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;the-idea&#34;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;There&amp;rsquo;s been a few ideas I have had in the past for browser-based games, ranging from barebones survival games, to casual online first-person shooters, to a lobby based dungeon crawler, but the investment is just so high. Then I realized that voxels are actually a brilliant building block, as ironic as that may sound.&lt;/p&gt;
&lt;p&gt;Most games and genres could play out perfectly well in a modified voxel engine. If there was a base voxel engine that just worked, then other games could be built on top of it. Creating an overhead RPG is just a matter of fixing the camera to 3rd person and rewiring the controls, creating an FPS is just fixing to a first person camera and hitscanning some projectiles.&lt;/p&gt;
&lt;h2 id=&#34;the-project&#34;&gt;The Project&lt;/h2&gt;
&lt;p&gt;The plan is to create a voxel-centric engine that can be rapidly developed into web-based games. This means networking, such that a server can provide a voxel world and syncronize entities in that world. This means generation and world editing, such that the engine can work as it&amp;rsquo;s own level editor. This means efficient rendering of a multitude of voxel types, useful default systems such as light, voxel physics, particles, dynamic voxels, etc.&lt;/p&gt;
&lt;p&gt;This blog is to document the project and the journey to creating it. It will contain technical breakdowns, engine work, design philosophy rambling, screenshots and demos, and hopefully some game development.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;banner.png&#34;
        alt=&#34;Voxel Landscape&#34;/&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>