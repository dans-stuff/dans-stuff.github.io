<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>architecture on WebVoxel Game Engine</title>
    <link>https://dans-stuff.github.io/blog/tags/architecture/</link>
    <description>Recent content in architecture on WebVoxel Game Engine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Apr 2021 21:22:09 -0700</lastBuildDate>
    
        <atom:link href="https://dans-stuff.github.io/blog/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>02 - Chunk Dependencies</title>
      <link>https://dans-stuff.github.io/blog/posts/02_chunk_dependencies/</link>
      <pubDate>Tue, 20 Apr 2021 21:22:09 -0700</pubDate>
      
      <guid>https://dans-stuff.github.io/blog/posts/02_chunk_dependencies/</guid>
      <description>&lt;h1 id=&#34;chunk-lifecycle&#34;&gt;Chunk Lifecycle&lt;/h1&gt;
&lt;p&gt;Early in development, I came across an issue that seems smalled at the time. Years later, I&amp;rsquo;m still fully coming to terms with it. That issue, is the dependant lifecycle of a chunk in the context of an infinite world of chunks.&lt;/p&gt;
&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;
&lt;p&gt;Consider an infinitely large world that is generated by a simple heightmap. This world is divided into chunks, and any chunk can be generated on demand as the player moves around.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;chunks.svg&#34;
        alt=&#34;Chunks&#34;/&gt;&lt;/p&gt;
&lt;p&gt;This can be managed very naively. You can generate any chunk within the area of the camera, and delete the memory as the camera moves away.&lt;/p&gt;
&lt;p&gt;They say that land, sea, plants and trees were created on the third day, and we can generate our land and sea, so let&amp;rsquo;s try to generate a tree!&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;tree.svg&#34;
        alt=&#34;Tree&#34;/&gt;&lt;/p&gt;
&lt;p&gt;Something went wrong here. The tree on the right is fine, but the tree on the left is missing 2 blocks. While generating our chunks, we generated them from left to right. This means that when the 2nd chunk generated, and the tree it contains was generated, part of the voxels that make up the tree were in the previous chunk&amp;hellip; but we had already created that chunk.&lt;/p&gt;
&lt;p&gt;This is a subtle, but incredibly important detail in voxel engines, but it is not specific to trees. There are many situations where a chunk might generate something that spreads into chunks that may have been created beforehand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Houses or villages&lt;/li&gt;
&lt;li&gt;Veins of ore or springs of water&lt;/li&gt;
&lt;li&gt;Caves, rivers&lt;/li&gt;
&lt;li&gt;Entire biomes, like deserts or oceans&lt;/li&gt;
&lt;li&gt;Linked items, like a map to treasure&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are all called &amp;ldquo;structures&amp;rdquo; and add a layer of complexity to world generation, and in this post I hope to share some of my learnings and my approach to handling them.&lt;/p&gt;
&lt;h2 id=&#34;step-1---chunks-under-construction&#34;&gt;Step 1 - Chunks Under Construction&lt;/h2&gt;
&lt;p&gt;The immediate solution is to just wait for the other chunks to be ready. Essentially, while generating a chunk, if we want to generate a tree that crosses into another chunk, we will wait until that other chunk has generated. We could even just generate the chunk just-in-time, when we are writing a voxel into it for the first time.&lt;/p&gt;
&lt;p&gt;This approach is simple and does work quite well, until suddenly your entire program freezes and crashes because 2 chunks both had trees that crossed into one another. This would be even more serious when structures cross multiple chunks. To solve this, we split chunks into phases.&lt;/p&gt;
&lt;h2 id=&#34;step-2---phased-generation&#34;&gt;Step 2 - Phased Generation&lt;/h2&gt;
&lt;p&gt;Splitting chunk generation into phases is a good solution to this problem. During phase 1, we generate the terrain, as it&amp;rsquo;s independent of surrounding terrain. Phase 2 can only begin when phase 1 has been completed in the surrounding chunks - which we can also do just-in-time. We call these chunks the &amp;ldquo;Landscape&amp;rdquo; phase and the &amp;ldquo;Structures&amp;rdquo; phase.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;phases.svg&#34;
        alt=&#34;Phases&#34;/&gt;&lt;/p&gt;
&lt;p&gt;This absolutely solves the problem. In fact, this solves the problem for quite a while.&lt;/p&gt;
&lt;p&gt;Earlier, I mentioned the &amp;ldquo;map and treasure&amp;rdquo; issue, which is where a map will be generated in a chunk, and it will lead you to a buried treasure dozens of chunks away. To solve that with our phased generation approach, we would need to &amp;ldquo;bury&amp;rdquo; treasure during phase 1, and generate the map in phase 2&amp;hellip; However, what if chunk containing the map is generated first?&lt;/p&gt;
&lt;p&gt;In this case, we have no choice but to search for a treasure for that map to point to, which means running phase 1 for potentially hundreds of chunks in a radius around the map. If the generation phase takes 2ms, it could take a second or more to generate a chunk. Let&amp;rsquo;s solve this issue.&lt;/p&gt;
&lt;h2 id=&#34;step-3---more-phases&#34;&gt;Step 3 - More Phases!&lt;/h2&gt;
&lt;p&gt;One observation is that we can decide where to bury the treasure before the actual terrain is generated. This applies to lots of structures, such as trees, caves and houses. We may still need to generate the terrain in a chunk before committing to our decision - perhaps a chunk is chosen but has no shoreline upon which to bury the treasure. That&amp;rsquo;s ok, because we can generate the landscape for that one specific chunk, and continue searching if it&amp;rsquo;s not suitable.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;morephases.svg&#34;
        alt=&#34;MorePhases&#34;/&gt;&lt;/p&gt;
&lt;p&gt;This is a very suitable solution in general. I&amp;rsquo;ve introduced the &amp;ldquo;seed&amp;rdquo; terminology, as all structures could be thought of as sprouting from a seed which is placed somewhere in a given chunk.&lt;/p&gt;
&lt;p&gt;To test this solution out, let&amp;rsquo;s consider 2 sprawling villages. The first consideration is that villages spread quite far - so for any chunk to finish generating, it needs a large neighborhood of chunks surrounding it to have finished phase 1, the seeding phase. This is totally fine. Deciding whether to place a village seed in a given chunk is a fast operation, so we can run this phase for hundreds of neighboring chunks in a few milliseconds.&lt;/p&gt;
&lt;p&gt;However, our 2 sprawling villages - let&amp;rsquo;s call them New York and Philly due to them being quite close together - suddenly introduce the same problem we had before. Generation would again depend on the order that chunks are generated. When Philly is generated first, and some of it&amp;rsquo;s buildings are generated into New York chunks, when we finally get to generating New York, some of the buildings it wants to generate would be occupied already. If we reverse our order and visit the other city first, then the same problem would apply.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;neighborhood.svg&#34;
        alt=&#34;Villages&#34;/&gt;&lt;/p&gt;
&lt;p&gt;This problem means our worlds are not deterministic. In fact, the most popular voxel-based game of all time suffers from this exact problem. I call this interference, and I have come up with 2 solutions to this problem.&lt;/p&gt;
&lt;h2 id=&#34;step-4a---destructive-interference&#34;&gt;Step 4a - Destructive Interference&lt;/h2&gt;
&lt;p&gt;My first solution was, in phase 1, generate both villages &lt;em&gt;in theory&lt;/em&gt;. Decide where the buildings and paths and people would go, for both cities. This also applies to all other nearby neighbors - generate the blueprints of fully grown structures ahead of time.&lt;/p&gt;
&lt;p&gt;Then have all the blueprints destructively interfere - if two buildings occupy the same area, neither building may generate. To consider other structures, you can implement a priority. For example, a building blueprint would take precedent over a tree blueprint. Two tree blueprints would nullify each other if they are too close, etc. This destruction would occur in a short phase after the seeding phase, you could consider it a phase 1b.&lt;/p&gt;
&lt;h2 id=&#34;step-4b---forced-ordering&#34;&gt;Step 4b - Forced Ordering&lt;/h2&gt;
&lt;p&gt;During generation, when we are running phase 1 seed placement for all neighboring chunks, we should apply those structures in a strict ordering, for example from -X to +X then -Y to +Y (or whatever your 2 horizontal dimensions are). This means that Philly will generate first, and then New York would generate second, regardless of which village was discovered first.&lt;/p&gt;
&lt;p&gt;This solution solves our problem without adding any extra complexity or computation.&lt;/p&gt;
&lt;p&gt;\1 Generate phase 1 seeding for a huge region of chunks
\2 Collect the list of chunks that might influence the current chunk, recursively
\3 Sort that list by chunk coordinate
\4 Bring all of those chunks up to the next phase in that order&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You might be realizing that this solution is not really perfect. For example, if you attempt to generate a chunk that is on the edge of a forest, it will recursively require every chunk in that entire forest to be past the seeding phase, and then will perform the expensive terrain generation phase for all of those chunks. Perfect deterministic terrain generation of inter-dependent chunks is actually a very complicated, almost untractable problem. You could realistically implement step 3 and accept the slight non-determinism.&lt;/p&gt;
&lt;p&gt;That said, there &lt;em&gt;is&lt;/em&gt; a perfect solution, which is an extension of &amp;ldquo;destructive intererence&amp;rdquo; that prevents the dependencies from becoming recursive, and I hope in a future post to cover that in detail.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>01 - Data Structures</title>
      <link>https://dans-stuff.github.io/blog/posts/01_data_structures/</link>
      <pubDate>Sun, 18 Apr 2021 21:40:12 -0700</pubDate>
      
      <guid>https://dans-stuff.github.io/blog/posts/01_data_structures/</guid>
      <description>&lt;h1 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h1&gt;
&lt;p&gt;Voxel engines come in many flavors. I want to compare and consider a few data structures for voxel data to find which is the most appropriate for this project.&lt;/p&gt;
&lt;h3 id=&#34;webvoxel-considerations&#34;&gt;WebVoxel Considerations&lt;/h3&gt;
&lt;p&gt;To accomplish WebVoxel&amp;rsquo;s goal, the engine should be flexible &lt;em&gt;enough&lt;/em&gt; to have many video game genres and mechanics layered on top, but must balance that against complexity. Here are some common ways in which the data structure will be important to a game developer building upon the engine:&lt;/p&gt;
&lt;p&gt;- Navigation. Players and NPC&amp;rsquo;s alike will be navigating the world in a manner specific and custom to the game.&lt;br&gt;
- Interaction. For some games, the voxel terrain may be nothing more than a solid static world, but for others interaction may be extremely high.&lt;br&gt;
- Rendering Performance. Every single game is going to be rendering the voxel scenes, but how dynamic the scene needs to be can have a big impact on how it is rendered.&lt;/p&gt;
&lt;p&gt;One important observation in all of these is the need to &lt;strong&gt;quickly traverse the immediate neighborhood&lt;/strong&gt; of any given point in space, that is, querying every voxel in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Moore_neighborhood&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;moore neighborhood&lt;/a&gt;
 of another voxel. Such traversal is used on physics, AI, lighting, pathfinding, and many general game elements. It&amp;rsquo;s important to understand the distinction between the terms &lt;strong&gt;iteration&lt;/strong&gt; and &lt;strong&gt;traversal&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Iteration&lt;/strong&gt; is visiting every single voxel, the order is irrelevant. The minimum theoretical  time to iterate an entire set of voxels is O(n) where n is the total amount of voxels.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Traversal&lt;/strong&gt; is visiting voxels in an order not determined ahead of time, such as visiting the neighborhood of a given voxel. The work of a voxel engine is equal parts iteration and traversal, therefor each data structure will be judged on those two requirements. Roughly speaking, traversal is the same as random access, though some data structures are faster to access nearby data. Traversal is measured per voxel traversed.&lt;/p&gt;
&lt;h1 id=&#34;breakdown&#34;&gt;Breakdown&lt;/h1&gt;
&lt;p&gt;Any complexity in the data structure could be abstracted, but any game will have custom demands that are not suitable for a base engine and it&amp;rsquo;s extremely important that any custom mechanics are not made more difficult by the complexity of the engine.&lt;/p&gt;
&lt;p&gt;So let&amp;rsquo;s take a look at 4 data structures which seem suitable. When using big-O notation, &lt;code&gt;n&lt;/code&gt; will indicate the total amount of voxels in our scene.&lt;/p&gt;
&lt;h2 id=&#34;data-structure-list&#34;&gt;Data Structure: List&lt;/h2&gt;
&lt;p&gt;&lt;img  src=&#34;list.png&#34;
        alt=&#34;List Diagram&#34;/&gt;&lt;/p&gt;
&lt;p&gt;The simplest data structure would be simply a list of voxels, specifying coordinate and type. Objects in game engines are almost always tracked in lists, as are particles. Lists are inclusive of a few data structures, from flat contiguous arrays, to linked list, to a heap that remains always sorted via some book-keeping during modifications.&lt;/p&gt;
&lt;p&gt;Pros&lt;br&gt;
+ The simplest in concept, adding a voxel to the world means adding it to a list&lt;br&gt;
+ Fast iteration and creation of voxels&lt;br&gt;
+ Memory usage scales with the amount of voxels&lt;br&gt;
+ Iteration is &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Extremely slow random access by coordinate, therefor slow traversal&lt;br&gt;
- Space inefficient for dense voxel scenes&lt;br&gt;
- Search time scales with voxel count at more than a constant rate&lt;br&gt;
- Performance can be improved at a rapid cost of increased complexity&lt;br&gt;
- Traversal in the average case is &lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For hundreds of voxels, perhaps thousands, the characteristics of a list are quite nice and in some cases will outperform the other options. For example, if voxels act more like particles with very high energy, moving from frame to frame, and only get deleted during iteration, this structure might be ideal.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lists&lt;/strong&gt; are immediately rejected as a candidate due to one major flaw, the scaling characteristics of traversal. Looking up a neighboring voxel is no faster than any random access, which is implemented as a search. While iteration is our desired &lt;code&gt;O(n)&lt;/code&gt;, traversal is a pretty bad &lt;code&gt;O(log n)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;data-structure-octree&#34;&gt;Data Structure: Octree&lt;/h2&gt;
&lt;p&gt;&lt;img  src=&#34;octree.png&#34;
        alt=&#34;Octree Diagram&#34;/&gt;&lt;/p&gt;
&lt;p&gt;This is the go-to data structure for sparse data, ie, data that tends to clump together. The short explanation is that octrees are a tree, where each branch encompasses a different region of space. If all of the data contained in a branch is the same, the branch is a &amp;ldquo;leaf&amp;rdquo; and has no children. If the data is varied, though, the branch if split into 8 smaller branches, each of which acts the same.&lt;/p&gt;
&lt;p&gt;In terms of voxels, this means large areas with identical voxels would be stored as a single leaf node, and only more detailed/varied areas would have deeper branches. The deeper the branches can go, the more detail you can represent.&lt;/p&gt;
&lt;p&gt;Pros:&lt;br&gt;
+ Extremely space efficient, capable of storing billions of voxels&lt;br&gt;
+ Changes to the tree provide deltas, efficient for networking&lt;br&gt;
+ Fast to raytrace, as large areas are skipped at each step&lt;br&gt;
+ Iteration is sort of &lt;code&gt;O(log n)&lt;/code&gt; with a twist&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Random access for a given coordinate is slow, especially when writing&lt;br&gt;
- Relatively complex to work with&lt;br&gt;
- Fixed size, tho new octrees could be created as needed for an infinite space&lt;br&gt;
- Traversal in the average case is &lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Octrees&lt;/strong&gt; are a tough contender, as they can be abstracted to provide random access queries, but at a performance cost. Collision detection gets a bonus here, as bounding-box queries into an octree can be the fastest of the options. The networking capability is another bonus, as octrees naturally provide contained deltas for any changes. When it comes to iteration, octrees are interesting: their nature allows for large regions of identical voxels to be skipped or treated as identical without needing to iterate them individually, but it may be hard to utilize that property in practice, though raytracing fully utilizes this property to achieve realtime performance.&lt;/p&gt;
&lt;p&gt;However, the complexity of octrees will undoubtedly leak to the game developer, and two of the pros are irrelevant in the context of a browser game which should not require hardware sufficient for raytracing nor interaction of billions of voxels.&lt;/p&gt;
&lt;h2 id=&#34;data-structure-hash-maps&#34;&gt;Data Structure: Hash Maps&lt;/h2&gt;
&lt;p&gt;&lt;img  src=&#34;hashmap.png&#34;
        alt=&#34;Hash Map Diagram&#34;/&gt;&lt;/p&gt;
&lt;p&gt;When you think of needing to index into a set of data, a hash map might seem like a viable data structure. The basic premise is that you create a key from the data to look at a specific bucket, then iterate that bucket to find the data you&amp;rsquo;re looking for.&lt;/p&gt;
&lt;p&gt;Pros:&lt;br&gt;
+ Easy to use, implemented natively in most languages&lt;br&gt;
+ Iteration is &lt;code&gt;O(n)&lt;/code&gt;&lt;br&gt;
+ Traversal in the average case is &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Space inefficient, as voxels need to store coordinate&lt;br&gt;
- Traversal time on average has a high constant factor&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hash Maps&lt;/strong&gt; seem like a good candidate in general, however internally there is a lot of book-keeping which applies to every read and write. There is no concept of locality, so traversal to a neighbor is the same as a random lookup. One major drawback is how the structure scales - more voxels mean more buckets, which means the buckets need to be rebalanced, which can have quite a high cost. If anything about this data structure is a show stopper, it&amp;rsquo;s the memory overhead, which is a very high constant of &lt;code&gt;O(n)&lt;/code&gt; not only due to the coordinates taking up space for each voxel, but the buckets and their padding taking up extra space.&lt;/p&gt;
&lt;h2 id=&#34;data-structure-pages&#34;&gt;Data Structure: Pages&lt;/h2&gt;
&lt;p&gt;&lt;img  src=&#34;pages.png&#34;
        alt=&#34;Paging Diagram&#34;/&gt;&lt;/p&gt;
&lt;p&gt;Pages are often called chunks in the context of voxels. With pages, space is divided into an even grid, which is paged in and out of memory as needed. All of the pages would represent the same amount of space, and is at minimum a large flat buffer where each element in the buffer is one voxel.&lt;/p&gt;
&lt;p&gt;For any given coordinate you can determine the page and index within that page with constant time math. Reading or writing to that index is also constant time, and extremely fast.&lt;/p&gt;
&lt;p&gt;Pros:&lt;br&gt;
+ Conceptually very simple&lt;br&gt;
+ Fast, constant-time read and write operations&lt;br&gt;
+ Naturally infinite in all dimensions&lt;br&gt;
+ Iteration is &lt;code&gt;O(n)&lt;/code&gt;&lt;br&gt;
+ Traversal is &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Cons:&lt;br&gt;
- Space inefficient, constant size regardless of data&lt;br&gt;
- Fixed world space partition size (fixed voxel size)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paging&lt;/strong&gt; is the strongest contender, mainly due to it&amp;rsquo;s balanced approach. The complexity is small, as the most naive and obvious way to work with the structure will usually be the correct one. The space requirements would often be problematic, but in the context of web-based games, the amount of voxels will be small. Constant-time operations will help deliver smooth, uninterrupted gameplay. Also, the main issue unique to pages is the scale of the voxels, which in the context of web-games can be considered a positive. Interactions and game rules will only need to consider voxels with a fixed size, and level or scene development will be kept consistent and predictable.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Comparison&lt;/th&gt;
&lt;th&gt;Space&lt;/th&gt;
&lt;th&gt;Traversal&lt;/th&gt;
&lt;th&gt;Iteration&lt;/th&gt;
&lt;th&gt;Complexity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Lists&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(2n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Medium&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Octrees&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(log n)*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;High&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hash Maps&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(2n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(1)*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Low&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pages&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Low&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To summarize these structures: lists are superceded by hash maps, and are only favorable for high-energy voxels; octrees are brilliant for everything but random access; hash maps are a simple solution but have unpredictable random access; and pages are space inefficient but predictable and simple in all other ways. One interesting observation is that hash maps and pages are extremely similar - they are both a contiguous list of voxels, partitioned by their coordinate. Pages are essentially a hash map, where the buckets are fixed-size to allow for addressing by coordinate rather than searching, which is exactly how they are implemented.&lt;/p&gt;
&lt;p&gt;For WebVoxel, pages seem to be the most reasonable solution. Web-based games are generally small in scope and complexity, because they target consumers with low-powered hardware, such as phones and laptops. They generally require low player commitment, and so the gameplay should be simple to learn quickly, which can be helped by fixed-size voxels. The benefits of a more complex data structure will never be realized in a web-based game. Runtime performance becomes important, but due to the size and detail of the scenes, memory is not much of a concern. Finally, predictability is a key asset, as we can now know ahead of time how the game developer will be using the voxel engine.&lt;/p&gt;
&lt;p&gt;That is why the core data structure of WebVoxel is buffers indexed by coordinate and paged in or out as needed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://dans-stuff.github.io/blog/about/</link>
      <pubDate>Sun, 18 Apr 2021 20:51:23 -0700</pubDate>
      
      <guid>https://dans-stuff.github.io/blog/about/</guid>
      <description>&lt;h2 id=&#34;the-dude&#34;&gt;The Dude&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;m Dan and I love difficult projects. My language of choice is Go, though I use native JavaScript when writing for the browser. If you want to contact me, my discord is SR|Dan#6804 and you can find me in the &lt;a href=&#34;https://discordapp.com/invite/anZVvmd&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Discord&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;the-idea&#34;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;There&amp;rsquo;s been a few ideas I have had in the past for browser-based games, ranging from barebones survival games, to casual online first-person shooters, to a lobby based dungeon crawler, but the investment is just so high. Then I realized that voxels are actually a brilliant building block, as ironic as that may sound.&lt;/p&gt;
&lt;p&gt;Most games and genres could play out perfectly well in a modified voxel engine. If there was a base voxel engine that just worked, then other games could be built on top of it. Creating an overhead RPG is just a matter of fixing the camera to 3rd person and rewiring the controls, creating an FPS is just fixing to a first person camera and hitscanning some projectiles.&lt;/p&gt;
&lt;h2 id=&#34;the-project&#34;&gt;The Project&lt;/h2&gt;
&lt;p&gt;The plan is to create a voxel-centric engine that can be rapidly developed into web-based games. This means networking, such that a server can provide a voxel world and syncronize entities in that world. This means generation and world editing, such that the engine can work as it&amp;rsquo;s own level editor. This means efficient rendering of a multitude of voxel types, useful default systems such as light, voxel physics, particles, dynamic voxels, etc.&lt;/p&gt;
&lt;p&gt;This blog is to document the project and the journey to creating it. It will contain technical breakdowns, engine work, design philosophy rambling, screenshots and demos, and hopefully some game development.&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;banner.png&#34;
        alt=&#34;Voxel Landscape&#34;/&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>