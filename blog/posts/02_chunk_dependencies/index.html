<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.82.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>02 - Chunk Dependencies&nbsp;&ndash;&nbsp;WebVoxel Game Engine</title><link rel="stylesheet" href="/blog/css/core.min.a436bbdaec2bf9f717098bfd9bfec1ff32bf4af601dfe878489f788a341a490858c079d1ba8996ad86c9df7926481712.css" integrity="sha384-pDa72uwr&#43;fcXCYv9m/7B/zK/SvYB3&#43;h4SJ94ijQaSQhYwHnRuomWrYbJ33kmSBcS"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="02 - Chunk Dependencies" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/blog/"><span class="site name">WebVoxel Game Engine</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/blog/">[All Posts]</a><a class="nav item" href="https://dans-stuff%2egithub%2eio/"target="_blank" rel="noopener noreferrer">[Live Demo]</a><a class="nav item" href="/blog/tags">[Post Tags]</a><a class="nav item" href="/blog/about">[About]</a></nav></div></span></div><div class="site slogan"><span class="title">Exploring voxels as a foundation for browser games</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">02 - Chunk Dependencies</h1><p class="article date">Tuesday, April 20, 2021</p></section><article class="article markdown-body"><h1 id="chunk-lifecycle">Chunk Lifecycle</h1>
<p>Early in development, I came across an issue that seems smalled at the time. Years later, I&rsquo;m still fully coming to terms with it. That issue, is the dependant lifecycle of a chunk in the context of an infinite world of chunks.</p>
<h2 id="context">Context</h2>
<p>Consider an infinitely large world that is generated by a simple heightmap. This world is divided into chunks, and any chunk can be generated on demand as the player moves around.</p>
<p><img  src="chunks.svg"
        alt="Chunks"/></p>
<p>This can be managed very naively. You can generate any chunk within the area of the camera, and delete the memory as the camera moves away.</p>
<p>They say that land, sea, plants and trees were created on the third day, and we can generate our land and sea, so let&rsquo;s try to generate a tree!</p>
<p><img  src="tree.svg"
        alt="Tree"/></p>
<p>Something went wrong here. The tree on the right is fine, but the tree on the left is missing 2 blocks. While generating our chunks, we generated them from left to right. This means that when the 2nd chunk generated, and the tree it contains was generated, part of the voxels that make up the tree were in the previous chunk&hellip; but we had already created that chunk.</p>
<p>This is a subtle, but incredibly important detail in voxel engines, but it is not specific to trees. There are many situations where a chunk might generate something that spreads into chunks that may have been created beforehand:</p>
<ul>
<li>Houses or villages</li>
<li>Veins of ore or springs of water</li>
<li>Caves, rivers</li>
<li>Entire biomes, like deserts or oceans</li>
<li>Linked items, like a map to treasure</li>
</ul>
<p>These are all called &ldquo;structures&rdquo; and add a layer of complexity to world generation, and in this post I hope to share some of my learnings and my approach to handling them.</p>
<h2 id="step-1---chunks-under-construction">Step 1 - Chunks Under Construction</h2>
<p>The immediate solution is to just wait for the other chunks to be ready. Essentially, while generating a chunk, if we want to generate a tree that crosses into another chunk, we will wait until that other chunk has generated. We could even just generate the chunk just-in-time, when we are writing a voxel into it for the first time.</p>
<p>This approach is simple and does work quite well, until suddenly your entire program freezes and crashes because 2 chunks both had trees that crossed into one another. This would be even more serious when structures cross multiple chunks. To solve this, we split chunks into phases.</p>
<h2 id="step-2---phased-generation">Step 2 - Phased Generation</h2>
<p>Splitting chunk generation into phases is a good solution to this problem. During phase 1, we generate the terrain, as it&rsquo;s independent of surrounding terrain. Phase 2 can only begin when phase 1 has been completed in the surrounding chunks - which we can also do just-in-time. We call these chunks the &ldquo;Landscape&rdquo; phase and the &ldquo;Structures&rdquo; phase.</p>
<p><img  src="phases.svg"
        alt="Phases"/></p>
<p>This absolutely solves the problem. In fact, this solves the problem for quite a while.</p>
<p>Earlier, I mentioned the &ldquo;map and treasure&rdquo; issue, which is where a map will be generated in a chunk, and it will lead you to a buried treasure dozens of chunks away. To solve that with our phased generation approach, we would need to &ldquo;bury&rdquo; treasure during phase 1, and generate the map in phase 2&hellip; However, what if chunk containing the map is generated first?</p>
<p>In this case, we have no choice but to search for a treasure for that map to point to, which means running phase 1 for potentially hundreds of chunks in a radius around the map. If the generation phase takes 2ms, it could take a second or more to generate a chunk. Let&rsquo;s solve this issue.</p>
<h2 id="step-3---more-phases">Step 3 - More Phases!</h2>
<p>One observation is that we can decide where to bury the treasure before the actual terrain is generated. This applies to lots of structures, such as trees, caves and houses. We may still need to generate the terrain in a chunk before committing to our decision - perhaps a chunk is chosen but has no shoreline upon which to bury the treasure. That&rsquo;s ok, because we can generate the landscape for that one specific chunk, and continue searching if it&rsquo;s not suitable.</p>
<p><img  src="morephases.svg"
        alt="MorePhases"/></p>
<p>This is a very suitable solution in general. I&rsquo;ve introduced the &ldquo;seed&rdquo; terminology, as all structures could be thought of as sprouting from a seed which is placed somewhere in a given chunk.</p>
<p>To test this solution out, let&rsquo;s consider 2 sprawling villages. The first consideration is that villages spread quite far - so for any chunk to finish generating, it needs a large neighborhood of chunks surrounding it to have finished phase 1, the seeding phase. This is totally fine. Deciding whether to place a village seed in a given chunk is a fast operation, so we can run this phase for hundreds of neighboring chunks in a few milliseconds.</p>
<p>However, our 2 sprawling villages - let&rsquo;s call them New York and Philly due to them being quite close together - suddenly introduce the same problem we had before. Generation would again depend on the order that chunks are generated. When Philly is generated first, and some of it&rsquo;s buildings are generated into New York chunks, when we finally get to generating New York, some of the buildings it wants to generate would be occupied already. If we reverse our order and visit the other city first, then the same problem would apply.</p>
<p><img  src="neighborhood.svg"
        alt="Villages"/></p>
<p>This problem means our worlds are not deterministic. In fact, the most popular voxel-based game of all time suffers from this exact problem. I call this interference, and I have come up with 2 solutions to this problem.</p>
<h2 id="step-4a---destructive-interference">Step 4a - Destructive Interference</h2>
<p>My first solution was, in phase 1, generate both villages <em>in theory</em>. Decide where the buildings and paths and people would go, for both cities. This also applies to all other nearby neighbors - generate the blueprints of fully grown structures ahead of time.</p>
<p>Then have all the blueprints destructively interfere - if two buildings occupy the same area, neither building may generate. To consider other structures, you can implement a priority. For example, a building blueprint would take precedent over a tree blueprint. Two tree blueprints would nullify each other if they are too close, etc. This destruction would occur in a short phase after the seeding phase, you could consider it a phase 1b.</p>
<h2 id="step-4b---forced-ordering">Step 4b - Forced Ordering</h2>
<p>During generation, when we are running phase 1 seed placement for all neighboring chunks, we should apply those structures in a strict ordering, for example from -X to +X then -Y to +Y (or whatever your 2 horizontal dimensions are). This means that Philly will generate first, and then New York would generate second, regardless of which village was discovered first.</p>
<p>This solution solves our problem without adding any extra complexity or computation.</p>
<p>\1 Generate phase 1 seeding for a huge region of chunks
\2 Collect the list of chunks that might influence the current chunk, recursively
\3 Sort that list by chunk coordinate
\4 Bring all of those chunks up to the next phase in that order</p>
<h2 id="conclusion">Conclusion</h2>
<p>You might be realizing that this solution is not really perfect. For example, if you attempt to generate a chunk that is on the edge of a forest, it will recursively require every chunk in that entire forest to be past the seeding phase, and then will perform the expensive terrain generation phase for all of those chunks. Perfect deterministic terrain generation of inter-dependent chunks is actually a very complicated, almost untractable problem. You could realistically implement step 3 and accept the slight non-determinism.</p>
<p>That said, there <em>is</em> a perfect solution, which is an extension of &ldquo;destructive intererence&rdquo; that prevents the dependencies from becoming recursive, and I hope in a future post to cover that in detail.</p>
</article><section class="article labels"><a class="tag" href=/blog/tags/engine/>engine</a><a class="tag" href=/blog/tags/architecture/>architecture</a></section><section class="article author"><p class="name">Dan</p><div class="bio">Engine Dev</div><div class="details"></div>
</section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/blog/posts/01_data_structures/"><span class="iconfont icon-article"></span>01 - Data Structures</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">WebVoxel Game Engine</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><script src="/blog/js/hljs.min.72e76ccf211868d08e31d7ca45c02501991bd760f28809c52045fa79fb7b7428664bb54ae875b46031ebc760c77b9562.js" integrity="sha384-cudszyEYaNCOMdfKRcAlAZkb12DyiAnFIEX6eft7dChmS7VK6HW0YDHrx2DHe5Vi"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>