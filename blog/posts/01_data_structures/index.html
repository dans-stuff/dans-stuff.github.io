<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.82.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>01 - Data Structures&nbsp;&ndash;&nbsp;WebVoxel Game Engine</title><link rel="stylesheet" href="/blog/css/core.min.a436bbdaec2bf9f717098bfd9bfec1ff32bf4af601dfe878489f788a341a490858c079d1ba8996ad86c9df7926481712.css" integrity="sha384-pDa72uwr&#43;fcXCYv9m/7B/zK/SvYB3&#43;h4SJ94ijQaSQhYwHnRuomWrYbJ33kmSBcS"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="01 - Data Structures" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/blog/"><span class="site name">WebVoxel Game Engine</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/blog/">[All Posts]</a><a class="nav item" href="https://dans-stuff%2egithub%2eio/"target="_blank" rel="noopener noreferrer">[Live Demo]</a><a class="nav item" href="/blog/tags">[Post Tags]</a><a class="nav item" href="/blog/about">[About]</a></nav></div></span></div><div class="site slogan"><span class="title">Exploring voxels as a foundation for browser games</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">01 - Data Structures</h1><p class="article date">Sunday, April 18, 2021</p></section><article class="article markdown-body"><h1 id="data-structures">Data Structures</h1>
<p>Voxel engines come in many flavors. I want to compare and consider a few data structures for voxel data to find which is the most appropriate for this project.</p>
<h2 id="list">List</h2>
<p>The simplest data structure would be simply a list of voxels, specifying coordinate and type. Objects in game engines are almost always tracked in lists, as are particles.</p>
<p>Pros<br>
+ The simplest in concept, adding a voxel to the world means adding it to a list<br>
+ Fast iteration, creation and deletion of voxels<br>
+ Memory usage scales with the amount of voxels</p>
<p>Cons:<br>
- Extremely slow random access by coordinate<br>
- Space inefficient for dense voxel scenes</p>
<p>Lists could have special behaviour, such as always being sorted to allow for binary-search lookups, but finding a voxel by coordinate will always amount to a search through the list.</p>
<h2 id="octree">Octree</h2>
<p>This is the go-to data structure for sparse data, ie, data that tends to clump together. The short explanation is that octrees are a tree, where each branch encompasses a different region of space. If all of the data contained in a branch is the same, the branch is a &ldquo;leaf&rdquo; and has no children. If the data is varied, though, the branch if split into 8 smaller branches, each of which acts the same.</p>
<p>In terms of voxels, this means large areas with identical voxels would be stored as a single leaf node, and only more detailed/varied areas would have deeper branches. The deeper the branches can go, the more detail you can represent.</p>
<p>Pros:<br>
+ Extremely space efficient, capable of storing billions of voxels<br>
+ Changes to the tree provide deltas, efficient for networking<br>
+ Fast to raytrace, as large areas are skipped at each step</p>
<p>Cons:<br>
- Random access for a given coordinate is slow, especially when writing<br>
- Relatively complex to work with<br>
- Fixed size, tho new octrees could be created as needed for an infinite space</p>
<h2 id="pages">Pages</h2>
<p>Pages are often called chunks in the context of voxels. With pages, space is divided into an even grid, which is paged in and out of memory as needed. All of the pages would represent the same amount of space, and is at minimum a large flat buffer where each element in the buffer is one voxel.</p>
<p>For any given coordinate you can determine the page and index within that page with constant time math. Reading or writing to that index is also constant time, and extremely fast.</p>
<p>Pros:<br>
+ Conceptually very simple<br>
+ Fast, constant-time read and write operations<br>
+ Naturally infinite in all dimensions</p>
<p>Cons:<br>
- Space inefficient, constant size regardless of data
- Fixed sense of scale</p>
<h2 id="in-the-context-of-webvoxel">In the context of WebVoxel</h2>
<p>Going back to WebVoxel&rsquo;s intention, the engine should be flexible <em>enough</em> to have many video game genres and mechanics layered on top, but must balance that against complexity. Here are some common ways in which the data structure will be important to a game developer building upom the engine:</p>
<p>- Navigation. Players and NPC&rsquo;s alike will be navigating the world in a manner specific and custom to the game.<br>
- Interaction. For some games, the voxel terrain may be nothing more than a solid static world, but for others interaction may be extremely high.<br>
- Rendering Performance. Every single game is going to be rendering the voxel scenes, but how dynamic the scene needs to be can have a big impact on how it is rendered.</p>
<p>Any complexity in the data structure could be abstracted, but any game will have custom demands that are not suitable for a base engine and it&rsquo;s extremely important that any custom mechanics are not made more difficult by the complexity of the engine.</p>
<p>Lists are immediately rejected as a candidate, because navigation would be impractical thanks to the slow random access by coordinate. That said, rendering and interacting with a list is not particularly bad, as iteration is fast and conceptually easy. The game developer could simply iterate through all voxels to see if any of them need to be interacted with in any way.</p>
<p>Octrees are a tough contender, as they can be abstracted to provide random access queries, but at a performance cost. Collision detection gets a bonus here, as bounding-box queries into an octree can be the fastest of the options. However, the complexity of octrees will undoubtedly leak to the game developer. Furthermore, two of the pros are irrelevant, as a browser game should not require hardware sufficient for raytracing, nor for interaction with billions of voxels. However, the networking capability is a very strong point in favor of octrees.</p>
<p>Paging is the strongest contender, mainly due to it&rsquo;s balanced approach. The complexity is small, as the most naive and obvious way to work with the structure will usually be the correct one. The space requirements would often be problematic, but in the context of web-based games, the amount of voxels will be small. Constant-time operations will help deliver smooth, uninterrupted gameplay. Also, the main issue unique to pages is the scale of the voxels, which in the context of web-games can be considered a positive. Interactions and game rules will only need to consider voxels with a fixed size, and level or scene development will be kept consistent and predictable.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion, pages make the most sense. Web-based games are much smaller in scope and complexity, because they target consumers with low-powered hardware, such as phones and laptops. Additionally, they generally require lower commitment, and so the gameplay should be simple to learn quickly. This means that the benefits of a more complex data structure will never be realized, and the performance of a simpler data structure will be unsufficient.</p>
<p>Going forward, the central data structure of WebVoxel will be buffers indexed by coordinate and paged in or out as needed.</p>
</article><section class="article labels"><a class="tag" href=/blog/tags/engine/>engine</a><a class="tag" href=/blog/tags/data/>data</a></section><section class="article author"><p class="name">Dan</p><div class="bio">Engine Dev</div><div class="details"></div>
</section>
</div>
<div class="article bottom"></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">WebVoxel Game Engine</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><script src="/blog/js/hljs.min.72e76ccf211868d08e31d7ca45c02501991bd760f28809c52045fa79fb7b7428664bb54ae875b46031ebc760c77b9562.js" integrity="sha384-cudszyEYaNCOMdfKRcAlAZkb12DyiAnFIEX6eft7dChmS7VK6HW0YDHrx2DHe5Vi"></script><script>hljs.initHighlightingOnLoad();</script></body>

</html>